/*
 * (c) 2025  ttelcl / ttelcl
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Win32;
using Microsoft.WindowsAPICodePack.Shell;

using LcLauncher.Main;
using System.IO;
using LcLauncher.Models;
using System.Text.RegularExpressions;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json;

namespace LcLauncher.ShellApps;

/// <summary>
/// Describes an item in the shell apps folder
/// </summary>
public class ShellAppDescriptor
{
  /// <summary>
  /// Create a new ShellAppDescriptor
  /// </summary>
  public ShellAppDescriptor(
    string label,
    string parsingName)
  {
    Label = label;
    if(HasShellAppsFolderPrefix(parsingName))
    {
      FullParsingName = parsingName;
      ParsingName = StripShellAppsPrefix(parsingName);
    }
    else
    {
      ParsingName = parsingName;
      FullParsingName = ShellAppsFolderPrefix + parsingName;
    }
    Kind = ShellAppKind.Unclassified;
    Classify();
  }

  public static ShellAppDescriptor FromShellObject(
    ShellObject shell)
  {
    return new ShellAppDescriptor(
      shell.Name,
      shell.ParsingName);
  }

  /// <summary>
  /// Create a Shell App Descriptor from an absolute or relative
  /// parsing name.
  /// </summary>
  public static ShellAppDescriptor? TryFromParsingName(
    string parsingName)
  {
    parsingName = WithShellAppsPrefix(parsingName);
    try
    {
      using var shellObject = ShellObject.FromParsingName(parsingName);
      return FromShellObject(shellObject);
    }
    catch(ShellException)
    {
      return null;
    }
  }

  [JsonConverter(typeof(StringEnumConverter))]
  [JsonProperty("kind")]
  public ShellAppKind Kind { get; private set; }

  /// <summary>
  /// The parsing name relative to the apps folder
  /// </summary>
  [JsonProperty("parsingname")]
  public string ParsingName { get; }

  /// <summary>
  /// The friendly display name of the app
  /// </summary>
  [JsonProperty("label")]
  public string Label { get; }

  /// <summary>
  /// The absolute parsing name (including the apps folder)
  /// </summary>
  [JsonIgnore]
  public string FullParsingName { get; }

  [JsonProperty("path")]
  public string? FileSystemPath { get; private set; }

  public bool ShouldSerializeFileSystemPath()
  {
    return FileSystemPath != null; 
  }

  [JsonIgnore]
  public AppIdLike? AppId { get; private set; }

  private void Classify()
  {
    // WIP!
    if(ParsingName.Length < 6)
    {
      Kind = ShellAppKind.Other;
      return;
    }
    if(ParsingName[1] == ':')
    {
      var drive = Char.ToUpper(ParsingName[0]);
      if(drive >= 'A' && drive <= 'Z')
      {
        // looks like a plain file name
        if(File.Exists(ParsingName))
        {
          Kind = ShellAppKind.PlainFileApp;
          FileSystemPath = ParsingName;
          return;
        }
        else if(Directory.Exists(ParsingName))
        {
          Kind = ShellAppKind.PlainFolderApp;
          FileSystemPath = ParsingName;
          return;
        }
        else
        {
          Trace.TraceWarning($"File-like parsing name does not exist: {ParsingName}");
          Kind = ShellAppKind.Other;
          return;
        }
      }
    }
    if(ParsingName[0] == '{')
    {
      var fileName = KnownFolderMap.ExpandKnownFolder(ParsingName);
      if(fileName[0] != '{')
      {
        Kind = ShellAppKind.FolderFileApp;
        FileSystemPath = fileName;
        return;
      }
      // else: fall through
    }
    if(ParsingName.StartsWith("Microsoft.AutoGenerated."))
    {
      Kind = ShellAppKind.Autogenerated;
      return;
    }
    var appIdLike = AppIdLike.TryParse(ParsingName);
    if(appIdLike != null)
    {
      Kind = ShellAppKind.AppId;
      AppId = appIdLike;
      return;
    }
    if(ParsingName.IndexOf(':') >= 2)
    {
      if(Regex.IsMatch(
              ParsingName,
              @"^[a-zA-Z][-+a-zA-Z0-9.]+:"))
      {
        Kind = ShellAppKind.UriKind;
        return;
      }
    }
    if(Regex.IsMatch(
      ParsingName,
      @"^[a-z][a-z0-9]+([-_][a-z0-9]+)*(\.[a-z0-9]+([-_][a-z0-9]+)*)*$",
      RegexOptions.IgnoreCase))
    {
      Kind = ShellAppKind.DottedName;
      return;
    }
    Kind = ShellAppKind.Other;
  }

  /// <summary>
  /// The prefix for the shell apps folder. Technically,
  /// this is case insensitive. Use <see cref="HasShellAppsFolderPrefix(string?)"/>
  /// to test for this prefix and its alternate form.
  /// </summary>
  public const string ShellAppsFolderPrefix =
    "shell:AppsFolder\\";

  public const string ShellAppsFolderPrefix2 =
    "shell:::{4234d49b-0245-4df3-B780-3893943456e1}\\";

  public static bool HasShellAppsFolderPrefix(string? target)
  {
    if(String.IsNullOrEmpty(target)
      || !target.StartsWith("shell:")) // case sensitive!
    {
      return false;
    }
    return
      target.StartsWith(
        ShellAppsFolderPrefix,
        StringComparison.InvariantCultureIgnoreCase)
      || target.StartsWith(
        ShellAppsFolderPrefix2,
        StringComparison.InvariantCultureIgnoreCase);
  }

  public static string StripShellAppsPrefix(string parsingName)
  {
    if(HasShellAppsFolderPrefix(parsingName))
    {
      var idx = parsingName.IndexOf('\\');
      if(idx < 0)
      {
        // Expecting anything that passes HasShellAppsFolderPrefix() to have at least one \
        throw new InvalidOperationException("Internal error");
      }
      return parsingName.Substring(idx+1);
    }
    else
    {
      return parsingName;
    }
  }

  public static string WithShellAppsPrefix(string parsingName)
  {
    if(!HasShellAppsFolderPrefix(parsingName))
    {
      return ShellAppsFolderPrefix + parsingName;
    }
    else
    {
      return parsingName;
    }
  }
}
